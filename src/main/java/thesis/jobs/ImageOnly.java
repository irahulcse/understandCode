package thesis.jobs;

import org.apache.flink.api.java.functions.KeySelector;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.BroadcastStream;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import thesis.common.sources.CameraSource;
import thesis.common.sources.PolicyCreator;
import thesis.context.VehicleContext;
import thesis.context.data.ImageData;
import thesis.demo.FlatMapper;
import thesis.flink.Descriptors;
import thesis.flink.FilterByDataSection;
import thesis.flink.SwitchingDecision;
import thesis.flink.sink.DataLogger;
import thesis.policy.Policy;
import thesis.util.*;

import java.io.IOException;
import java.util.*;

/**
 * <p>The evaluation job for Variant 3 distributed PET enforcement
 * This job uses simulated switching signals generated by {@link SituationEvaluatorSimulatorDuoUpgrade}.
 * The switching decisions have UUID to distinguish from each other for the purpose of evaluation.</p>
 * <p>Components for evaluation are {@link OutputTool}, timer task that measures {@link MemoryUsage}</p>
 *
 */
public class ImageOnly {

//    private static final String petPath1 = GlobalConfig.textInputSource + "/petDescriptions/imagePET1.json";
//    private static final String petPath2 = GlobalConfig.textInputSource + "/petDescriptions/imagePET2.json";
//    private static final String petPath3 = GlobalConfig.textInputSource + "/petDescriptions/imagePET3.json";

    public static OutputTool outputTool;
    private static final Timer timer = new Timer();
    public static int frequency = 25;

    static {
        try {
            outputTool = new OutputTool();
            Runtime.getRuntime().addShutdownHook(outputTool.complete(true));
        } catch (IOException e) {
            System.out.println("Error initializing output tool.");
        }
    }

    public static Map<Integer, UUID> triggerIDMapping = new HashMap<>();

    public static void main(String[] args) throws Exception {

        startMemoryLogger();

        for (int i = 0; i < 110; i++) {
            triggerIDMapping.put(i, UUID.randomUUID());
        }

        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(1);

        DataStream<ImageData> cameraStream = env.addSource(new CameraSource(frequency,1100));
        BroadcastStream<Policy> policyBroadcastStream = env.fromElements(PolicyCreator.generatePolicy("demoPolicy")).broadcast(Descriptors.policyStateDescriptor);

        KeyedStream<Tuple2<String, VehicleContext>, String> keyedContextStream = cameraStream.flatMap(new FlatMapper<>()).keyBy((KeySelector<Tuple2<String, VehicleContext>, String>) value -> value.f0);
        //SingleOutputStreamOperator<SwitchingDecision> decisionMaker = keyedContextStream.connect(policyBroadcastStream).process(new SituationEvaluatorSimulatorUpgrade(triggerIDMapping, petPath1, petPath2)).setParallelism(1);
        SingleOutputStreamOperator<SwitchingDecision> decisionMaker = keyedContextStream.connect(policyBroadcastStream).process(new SituationEvaluatorSimulatorDuoUpgrade(triggerIDMapping,300)).setParallelism(1);

        BroadcastStream<SwitchingDecision> broadcastDecisions = decisionMaker.broadcast(Descriptors.decisionMapState);
        DataStream<Tuple2<String, VehicleContext>> forkedVehicleContextRecords = decisionMaker.getSideOutput(SituationEvaluatorSimulator.contextOutputTag);

        DataStream<Tuple2<String, VehicleContext>> imageSplit = forkedVehicleContextRecords.filter(new FilterByDataSection("image"));
        DataStream<Tuple2<String, VehicleContext>> processedImage = PipelineUtil.getOrderedOutputStream(env, "app1", 8, "image", ImageData.class, false,broadcastDecisions, imageSplit);
        //processedImage.addSink(new ImageSink(frequency));
        processedImage.addSink(new DataLogger());

        env.execute("image only");

    }

    private static void startMemoryLogger() {
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                long freeMem = Runtime.getRuntime().freeMemory();
                long maxMem = Runtime.getRuntime().maxMemory();
                long totalMem = Runtime.getRuntime().totalMemory();
                try {
                    OutputTool.log(new MemoryUsage(System.currentTimeMillis(), maxMem, totalMem, freeMem), "");
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }, 2000, 1000);
    }
}
